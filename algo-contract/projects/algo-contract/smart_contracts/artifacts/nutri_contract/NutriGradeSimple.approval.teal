#pragma version 10
#pragma typetrack false

// smart_contracts.nutri_contract.contract.NutriGradeSimple.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1
    bytecblock 0x151f7c75 "total_products" "owner" "total_scans" "user_scan_count" "last_scanned_product"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/nutri_contract/contract.py:26-27
    // # Global state - contract level data
    // self.owner = GlobalState(Txn.sender)
    bytec_2 // "owner"
    txn Sender
    app_global_put
    // smart_contracts/nutri_contract/contract.py:28
    // self.total_products = GlobalState(UInt64(0))
    bytec_1 // "total_products"
    intc_0 // 0
    app_global_put
    // smart_contracts/nutri_contract/contract.py:29
    // self.total_scans = GlobalState(UInt64(0))
    bytec_3 // "total_scans"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/nutri_contract/contract.py:13
    // class NutriGradeSimple(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@15
    pushbytess 0x54391946 0xf1e61691 0x3af35294 0xe67daf51 0x32e3a2ad 0x122238f2 0x6984ee98 0x1c7d5965 0xff2ba5c5 0x2fba5a1b // method "bootstrap()string", method "add_product(string,string,string)string", method "scan_product(string)string", method "get_stats()(uint64,uint64)", method "get_user_stats()(uint64,string)", method "opt_in()string", method "opt_out()string", method "update_product(string,string,string)string", method "get_owner()address", method "get_version()string"
    txna ApplicationArgs 0
    match main_bootstrap_route@5 main_add_product_route@6 main_scan_product_route@7 main_get_stats_route@8 main_get_user_stats_route@9 main_opt_in_route@10 main_opt_out_route@11 main_update_product_route@12 main_get_owner_route@13 main_get_version_route@14

main_after_if_else@17:
    // smart_contracts/nutri_contract/contract.py:13
    // class NutriGradeSimple(ARC4Contract):
    intc_0 // 0
    return

main_get_version_route@14:
    // smart_contracts/nutri_contract/contract.py:203
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c7500184e7574726947726164652053696d706c652076312e302e30
    log
    intc_1 // 1
    return

main_get_owner_route@13:
    // smart_contracts/nutri_contract/contract.py:193
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_owner
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_update_product_route@12:
    // smart_contracts/nutri_contract/contract.py:169
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/nutri_contract/contract.py:13
    // class NutriGradeSimple(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/nutri_contract/contract.py:169
    // @arc4.abimethod
    callsub update_product
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_opt_out_route@11:
    // smart_contracts/nutri_contract/contract.py:158
    // @arc4.abimethod(allow_actions=["CloseOut"])
    txn OnCompletion
    pushint 2 // CloseOut
    ==
    assert // OnCompletion is not CloseOut
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c75001f5468616e6b20796f7520666f72207573696e67204e75747269477261646521
    log
    intc_1 // 1
    return

main_opt_in_route@10:
    // smart_contracts/nutri_contract/contract.py:143
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub opt_in
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_user_stats_route@9:
    // smart_contracts/nutri_contract/contract.py:119
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_user_stats
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_stats_route@8:
    // smart_contracts/nutri_contract/contract.py:104
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_stats
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_scan_product_route@7:
    // smart_contracts/nutri_contract/contract.py:75
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/nutri_contract/contract.py:13
    // class NutriGradeSimple(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/nutri_contract/contract.py:75
    // @arc4.abimethod
    callsub scan_product
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_add_product_route@6:
    // smart_contracts/nutri_contract/contract.py:47
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/nutri_contract/contract.py:13
    // class NutriGradeSimple(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/nutri_contract/contract.py:47
    // @arc4.abimethod
    callsub add_product
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bootstrap_route@5:
    // smart_contracts/nutri_contract/contract.py:35
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub bootstrap
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@15:
    // smart_contracts/nutri_contract/contract.py:13
    // class NutriGradeSimple(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@17
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.nutri_contract.contract.NutriGradeSimple.bootstrap() -> bytes:
bootstrap:
    // smart_contracts/nutri_contract/contract.py:38
    // assert Txn.sender == self.owner.value, "Only owner can bootstrap"
    txn Sender
    intc_0 // 0
    bytec_2 // "owner"
    app_global_get_ex
    assert // check self.owner exists
    ==
    assert // Only owner can bootstrap
    // smart_contracts/nutri_contract/contract.py:39
    // assert self.total_products.value == UInt64(0), "Already bootstrapped"
    intc_0 // 0
    bytec_1 // "total_products"
    app_global_get_ex
    assert // check self.total_products exists
    !
    assert // Already bootstrapped
    // smart_contracts/nutri_contract/contract.py:41-42
    // # Set initial state
    // self.total_products.value = UInt64(0)
    bytec_1 // "total_products"
    intc_0 // 0
    app_global_put
    // smart_contracts/nutri_contract/contract.py:43
    // self.total_scans.value = UInt64(0)
    bytec_3 // "total_scans"
    intc_0 // 0
    app_global_put
    // smart_contracts/nutri_contract/contract.py:45
    // return arc4.String("NutriGrade Contract Initialized Successfully!")
    pushbytes 0x002d4e75747269477261646520436f6e747261637420496e697469616c697a6564205375636365737366756c6c7921
    retsub


// smart_contracts.nutri_contract.contract.NutriGradeSimple.add_product(product_id: bytes, name: bytes, ingredients: bytes) -> bytes:
add_product:
    // smart_contracts/nutri_contract/contract.py:47-53
    // @arc4.abimethod
    // def add_product(
    //     self,
    //     product_id: arc4.String,
    //     name: arc4.String,
    //     ingredients: arc4.String,
    // ) -> arc4.String:
    proto 3 1
    // smart_contracts/nutri_contract/contract.py:66-67
    // # Only owner can add products
    // assert Txn.sender == self.owner.value, "Only owner can add products"
    txn Sender
    intc_0 // 0
    bytec_2 // "owner"
    app_global_get_ex
    assert // check self.owner exists
    ==
    assert // Only owner can add products
    // smart_contracts/nutri_contract/contract.py:69-71
    // # In a real implementation, we'd store this in box storage
    // # For demo purposes, we're just incrementing the counter
    // self.total_products.value = self.total_products.value + UInt64(1)
    intc_0 // 0
    bytec_1 // "total_products"
    app_global_get_ex
    assert // check self.total_products exists
    intc_1 // 1
    +
    bytec_1 // "total_products"
    swap
    app_global_put
    // smart_contracts/nutri_contract/contract.py:73
    // return arc4.String("Product added successfully!")
    pushbytes 0x001b50726f64756374206164646564207375636365737366756c6c7921
    retsub


// smart_contracts.nutri_contract.contract.NutriGradeSimple.scan_product(product_id: bytes) -> bytes:
scan_product:
    // smart_contracts/nutri_contract/contract.py:75-79
    // @arc4.abimethod
    // def scan_product(
    //     self,
    //     product_id: arc4.String,
    // ) -> arc4.String:
    proto 1 1
    // smart_contracts/nutri_contract/contract.py:92
    // Txn.sender, op.Global.current_application_id
    txn Sender
    global CurrentApplicationID
    // smart_contracts/nutri_contract/contract.py:90-93
    // # Opt-in check for local state
    // assert op.app_opted_in(
    //     Txn.sender, op.Global.current_application_id
    // ), "Please opt-in first"
    app_opted_in
    assert // Please opt-in first
    // smart_contracts/nutri_contract/contract.py:95-96
    // # Update global scan count
    // self.total_scans.value = self.total_scans.value + UInt64(1)
    intc_0 // 0
    bytec_3 // "total_scans"
    app_global_get_ex
    assert // check self.total_scans exists
    intc_1 // 1
    +
    bytec_3 // "total_scans"
    swap
    app_global_put
    // smart_contracts/nutri_contract/contract.py:98-99
    // # Update user's local state
    // self.user_scan_count[Txn.sender] = self.user_scan_count[Txn.sender] + UInt64(1)
    txn Sender
    intc_0 // 0
    bytec 4 // "user_scan_count"
    app_local_get_ex
    assert // check self.user_scan_count exists for account
    intc_1 // 1
    +
    txn Sender
    bytec 4 // "user_scan_count"
    uncover 2
    app_local_put
    // smart_contracts/nutri_contract/contract.py:100
    // self.last_scanned_product[Txn.sender] = product_id.native
    frame_dig -1
    extract 2 0
    txn Sender
    bytec 5 // "last_scanned_product"
    uncover 2
    app_local_put
    // smart_contracts/nutri_contract/contract.py:102
    // return arc4.String("Product scanned successfully!")
    pushbytes 0x001d50726f64756374207363616e6e6564207375636365737366756c6c7921
    retsub


// smart_contracts.nutri_contract.contract.NutriGradeSimple.get_stats() -> bytes:
get_stats:
    // smart_contracts/nutri_contract/contract.py:114
    // arc4.UInt64(self.total_products.value),
    intc_0 // 0
    bytec_1 // "total_products"
    app_global_get_ex
    assert // check self.total_products exists
    itob
    // smart_contracts/nutri_contract/contract.py:115
    // arc4.UInt64(self.total_scans.value),
    intc_0 // 0
    bytec_3 // "total_scans"
    app_global_get_ex
    assert // check self.total_scans exists
    itob
    // smart_contracts/nutri_contract/contract.py:112-117
    // return arc4.Tuple(
    //     (
    //         arc4.UInt64(self.total_products.value),
    //         arc4.UInt64(self.total_scans.value),
    //     )
    // )
    concat
    retsub


// smart_contracts.nutri_contract.contract.NutriGradeSimple.get_user_stats() -> bytes:
get_user_stats:
    // smart_contracts/nutri_contract/contract.py:127-128
    // # Check if user has opted in
    // if not op.app_opted_in(Txn.sender, op.Global.current_application_id):
    txn Sender
    global CurrentApplicationID
    app_opted_in
    bnz get_user_stats_after_if_else@2
    // smart_contracts/nutri_contract/contract.py:129-134
    // return arc4.Tuple(
    //     (
    //         arc4.UInt64(0),
    //         arc4.String("No scans yet"),
    //     )
    // )
    pushbytes 0x0000000000000000000a000c4e6f207363616e7320796574
    retsub

get_user_stats_after_if_else@2:
    // smart_contracts/nutri_contract/contract.py:138
    // arc4.UInt64(self.user_scan_count[Txn.sender]),
    txn Sender
    intc_0 // 0
    bytec 4 // "user_scan_count"
    app_local_get_ex
    assert // check self.user_scan_count exists for account
    itob
    // smart_contracts/nutri_contract/contract.py:139
    // arc4.String(self.last_scanned_product[Txn.sender]),
    txn Sender
    intc_0 // 0
    bytec 5 // "last_scanned_product"
    app_local_get_ex
    assert // check self.last_scanned_product exists for account
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/nutri_contract/contract.py:136-141
    // return arc4.Tuple(
    //     (
    //         arc4.UInt64(self.user_scan_count[Txn.sender]),
    //         arc4.String(self.last_scanned_product[Txn.sender]),
    //     )
    // )
    swap
    pushbytes 0x000a
    concat
    swap
    concat
    retsub


// smart_contracts.nutri_contract.contract.NutriGradeSimple.opt_in() -> bytes:
opt_in:
    // smart_contracts/nutri_contract/contract.py:152-153
    // # Initialize user's local state
    // self.user_scan_count[Txn.sender] = UInt64(0)
    txn Sender
    bytec 4 // "user_scan_count"
    intc_0 // 0
    app_local_put
    // smart_contracts/nutri_contract/contract.py:154
    // self.last_scanned_product[Txn.sender] = String("")
    txn Sender
    bytec 5 // "last_scanned_product"
    pushbytes ""
    app_local_put
    // smart_contracts/nutri_contract/contract.py:156
    // return arc4.String("Welcome to NutriGrade! You can now scan products.")
    pushbytes 0x003157656c636f6d6520746f204e7574726947726164652120596f752063616e206e6f77207363616e2070726f64756374732e
    retsub


// smart_contracts.nutri_contract.contract.NutriGradeSimple.update_product(product_id: bytes, name: bytes, ingredients: bytes) -> bytes:
update_product:
    // smart_contracts/nutri_contract/contract.py:169-175
    // @arc4.abimethod
    // def update_product(
    //     self,
    //     product_id: arc4.String,
    //     name: arc4.String,
    //     ingredients: arc4.String,
    // ) -> arc4.String:
    proto 3 1
    // smart_contracts/nutri_contract/contract.py:188-189
    // # Only owner can update
    // assert Txn.sender == self.owner.value, "Only owner can update products"
    txn Sender
    intc_0 // 0
    bytec_2 // "owner"
    app_global_get_ex
    assert // check self.owner exists
    ==
    assert // Only owner can update products
    // smart_contracts/nutri_contract/contract.py:191
    // return arc4.String("Product updated successfully!")
    pushbytes 0x001d50726f647563742075706461746564207375636365737366756c6c7921
    retsub


// smart_contracts.nutri_contract.contract.NutriGradeSimple.get_owner() -> bytes:
get_owner:
    // smart_contracts/nutri_contract/contract.py:201
    // return arc4.Address(self.owner.value)
    intc_0 // 0
    bytec_2 // "owner"
    app_global_get_ex
    assert // check self.owner exists
    retsub
